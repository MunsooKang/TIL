# Class

## 절차 지향 프로그래밍(Procedural Programming)
프로그램을 '데이터'와 '절차'로 구성하는 방식의 프로그래밍 패러다임
 1. 특징
 * '데이터'와 해당 데이터를 처리하는 '함수(절차)'가 분리되어 있으며, <함수 호출의 흐름>이 중요
 * 데이터를 다시 재사용하기보단, 처음부터 끝까지 실행되는 결과물이 중요
 2. 소프트웨어 위기
 * 하드웨어의 발전으로 계산용량 및 문제 복잡성이 급격히 증가하여, 절차 지향의 한계가 나타남

## 객체지향 프로그래밍
* '데이터'와 해당 데이터를 조작하는 '메서드'를 **하나의 객체**로 묶어 관리하는 방식의 프로그래밍 패러다임
* 절차지향(데이터, 함수) → 객체지향(클래스, 데이터, 메서드) paradigm shift
* (비교) - 절차지향 : 함수(데이터) ↔ 객체지향 : 데이터(객체)


1. 클래스 Class
* 파이썬에서 타입을 표현하는 방법
* 객체를 생성하기 위한 설계도, 데이터와 기능을 함께 묶는 방법을 제공

 1-1 객체 Object
 <br/>클래스에서 정의한 것을 토대로 메모리에 할당된 것, '속성(변수)'과 '행동(메서드)'으로 구성된 모든 것
  * 클래스(상위 객체)로 만든 객체를 '인스턴스' 라고 한다
  * class는 type를 만들어 낸다.
  
  (1) calss와 객체
  <br/>변수 name의 타입은 str 클래스다.
  <br/> 변수 name은 str클래스의 인스턴스이다.
  ```
  name = 'Alice'
  print(type(name) # <class 'str'>)
  ```
  
  (2) 인스턴스와 메서드
  <br/>"hello".upper()
  <br/>== 문자열.대문자로
  <br/>== 객체.행동()
  <br/>== 인스턴스.메서드()

  (3) 객체의 특징
  <br/>타입 : 어떤 연산자와 조작이 가능한가?
  <br/>속성 : 어떤 상태(데이터)를 가지는가?
  <br/>조작법 : 어떤 행위(함수)를 할 수 있는가?

  1-2 클래스 기본 활용
  ```
  # 클래스 정의
class Person:
    # 속성(변수)
    blood_color = 'red'

    # 메서드
    def __init__(self, name):
        self.name = name

    def singing(self):
        return f'{self.name}가 노래합니다.'

# 인스턴스 생성
singer1 = Person('iu')
singer2 = Person('taeyeon')

# 메서드 호출
print(singer1.singing())
print(singer2.singing())

# 속성(변수) 사용
print(singer1.blood_color)
print(singer2.blood_color)
  ```
  * 생성자 함수
  (1)
  (2)
  (3)
  * 인스턴스 변수
  (1) 인스턴스(객체)마다 별도로 유지되는 변수
  (2) 인스턴스마다 '독립적인 값'을 가지며, 인스턴스가 생성될 때마다 '초기화'됨
  * 클래스 변수
  (1) 클래스 내부에 선언된 변수
  (2) 클래스로 생성된 모든 인스턴스들이 공유하는 변수
  * 인스턴스 메서드
  (1) 각각의 인스턴스에서 호출할 수 있는 메서드
  (2) 인스턴스 변수에 접근하고 수정하는 등의 작업을 수행

  1-3 인스턴스와 클래스 간의 이름 공간(namespaece)
  * 각 인스턴스는 독립적인 이름(메모리)공간을 지닌다.
  <br/> 클래스와 다른 인스턴스 간에는 서로의 데이터에 직접적인 접근이 불가능

2. 메서드
* 메서드 종류 : 인스턴스 메서드, 클래스 메서드, 정적 메서드

  2-1 인스턴스 메서드
  <br/> 인스턴스의 상태를 조작하거나 동작을 수행
  * 인스턴스 메서드 구조
  <br/> 클래스 내부에 정의되는 메서드의 기본
  <br/> 반드시 첫 번째 매개변수로 인스턴스 자신(self)을 전달받음
  <br/> 매개변수명 'self'는 암묵적 약속, 다른 것으로 명명해도 작동한다.
  ```
  class MyClass:

    def instance_method(self, arg1, ...):
        pass
  ```
  
  ```
  # 인스턴스.메서드()
  'abc'.upper() # == str.upper('abc')

  # 클래스.메서드(인스턴스 자기자신)
  str.upper('abc') # why? upper는 'str' class의 인스턴스 메서드
  ```

  2-2
  * 클래스 변수를 조작하거나, 클래스 레벨의 동작을 수행
  * 클래스 메서드 구조
  <br/> @classmethod 데코레이터를 사용하여 정의
  <br/> 호출 시, 첫번째 인자로 호출하는 클래스(cls)가 전달됨
  ```
  class MyClass:

      @classmethod # 데코레이터, 클래스 메서드로 꾸며준다.
      def class_method(cls, arg1, ...):
          pass

  ```

  2-3 스태틱(정적) 메서드
* 클래스, 인스턴스와 상관없이 독립적으로 동작하는 메서드
```
class MyClass:

      @staticmethod # 반드시 필요한 매개변수가 없다(self, cls 등)
      def static_method(arg1, ...):
          pass
```
3. 메서드 정리
  3-1 인스턴스 메서드
* 인스턴스의 상태를 변경하거나, 해당 인스턴스의 특정 동작을 수행( 첫 매개변수 self)
  
  3-2 클래스 메서드
* 인스턴스의 상태에 의존하지 않는 기능을 정의(첫 매개변수 cls)
* 클래스 변수를 조작하거나, 클래스 레벨의 동작을 수행

  3-3 스태틱 메서드
* 클래스 및 인스턴스와 관련이 없는 일반적인 기능을 수행

4. 각자의 역할
* 클래스가 사용해야 할 것 : 클래스 메서드, 스태틱 메서드
* 인스턴스가 사용해야 할 것 : 인스턴스 메서드

# 오후 수업

## 객체
1. Object
* key과 value로 구성(dict과 유사)
* 속성(상태)와 행동(메서드)의 집합
{
  'height' : 200,
  'drink' : drink
}

def drink():
    height + 1

