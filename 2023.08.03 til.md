# Array 2



### 부분집합의 합

1. 부분집합의 수

   - 집합의 원소가 n 개 → 부분집합의 수 2^n개

     | 1      | 2      | 3      | 4      |
     | ------ | ------ | ------ | ------ |
     | 1 or 0 | 1 or 0 | 1 or 0 | 1 or 0 |

     ``` 
     def print_subset(bit, arr, n):
     	for i in range(n):
     		if bit[i]: # == ( if bit[i] == 1 )
     			print(arr[i], end = '')
     			
     bit = [ 0, 0, 0, 0]
     for i in ragne(2):
     	bit[0] = i
     	for j in range(2):
     		bit[1] = j
     		for k in range(2):
     			bit[2] = k
     			for l in range(2):
     				bit[3] = l
     				print(subset(bit))
     ```

2. 비트 연산자

|  &   | 비트 단위로 AND 연산을 한다.                |
| :--: | ------------------------------------------- |
|  \|  | 비트 단위로 OR 연산을 한다.                 |
|  <<  | 피연산자의 비트 열을 왼쪽으로 이동시킨다.   |
|  >>  | 피연산자의 비트 열을 오른쪽으로 이동시킨다. |

​	(1)  << 연산자

​	  * a = 0 0 0 0 0 1 (비트 단위, 이진수  0,1 로만 표현됨)

​	*  a << 4  : 0 1 0 0 0 0  (비트 단위)

​		* 1 << n : 2^n 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미한다. == n번 비트가 1인 값

(2) & 연산자

- i &(1 << j) : i의 j번째 비트가 1인지 아닌지를 검사한다.

- 연산의 결과가 1 -> True, 0-> False

- ```
  arr = [1, 2, 3]
  
  n = len(arr)  # n : 원소의 개수
  
  for i in range(1 << n):  # 1 << n : 부분 집합의 개수
  	for j in range(n):   # 원소의 수만큼 비트를 비교함
  		if i & (1 << j): # i의 j번 비트가 1인 경우
  			print(arr[j], end= ",")  # j번 원소 출력
  	print()
  print()
  
  # 원소의 개수가 3개(n개) -> 10진수 0~7(0 ~ 2의n승-1)로 표현 가능 -> 2의 3승(n승)
  
  ```



## 검색

1. 순차 검색

   * 일렬로 되어 있는 자료를 순서대로 검색하는 방법

     - 가장 간단하고 직관적인 검색 방법
     - 배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 항목을 찾을 떄 유용하다.
     - 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우 수행시간이 급격히 증가하여 비효율적이다.

   *  2가지 경우

     * (1) 정렬되어 있지 않은 경우
     * (2) 정렬되어 있는 경우

     (1) 검색 과정

     * 첫 번째 원소부터 순서대로 검색, 값을 찾으면 해당 인덱스를 반환

     * 찾고자 하는 원소의 순서에 따라 비교회수가 결정됨. 

     * 정렬되지 않은 자료에서 순차 검색의 평균 비교 회수 = (n+1)/2, 시간 복잡도 O(n)

       

 2. 이진 검색(Binary Search)★ 

    * 자료의 **가운데에 있는 항목의 key 값과 비교**하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법 

    * 목적 키를 찾을 때까지 이진 검색을 **순환적으로 반복 수행함**으로써 검색 범위를 반으로 줄여가며 보다 빠르게 검색을 수행함

    * 이진 검색을 하기 위해서는 **자료가 정렬**된 상태여야 한다

    (1) 구현

    ```
    def binarySerch(a, N, key)
    	start = 0
    	end = N-1
    	while start <= end:  # 탐색 구간이 존재하면, == 원소가 한 개 이상 이면
    		middle = (start + end) // 2
    		if a[middle] == key:: 
    			return True
    		elif a[middle] > key:
    			end = middle - 1
    		else:
    			start = middle +1
    	return False  # 검색 실패(==더 검색할 원소가 없으면)
    ```

    (2) 재귀 함수 이용

     ```
     교재 참조
     ```

    

3.  인덱스

   * ???

4.  선택 정렬★ ( ↔ 버블 정렬)

   * 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
   * 정렬 과정
     * 주어진 리스트 중에서 최소값을 찾는다.
     * 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
     * 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다

   ※ 주의사항 : 버블 정렬과 선택 정렬을 정확히 구분하기, 둘이 섞인 코드를 구현하는 경우가 많음

   * 시간 복잡도 : O(n^2)

   * min_idx = i인덱스를 활용하여 계산한다.

   * ```
     def SelectionSort(a[], n):
     	for i in range(N-1):
     		min_idx = i
     		for j in range(i+1, N):
     			if a[min_idx] > a[j]:
     				min_idx = j
     		a[i], a[min_idx] = a[min_idx], a[i]  # 반복문 내 교환 위치 잘 확인
     ```

   * 

5.  셀렉션 알고리즘
   * 저장되어 있는 자료로부터 k번째로 큰 or 작은 원소를 찾는 방법(==최소,최대,중간값을 찾는 알고리즘)
   * 선택 과정
     * 정렬 알고리즘을 이용하여 자료 정렬하기
     * 원하는 순서에 있는 원소 가져오기
   * ![image-20230803104838252](C:\Users\SSAFY\AppData\Roaming\Typora\typora-user-images\image-20230803104838252.png)



# 시험

3문제

1번 50점, 2번 30점, 3번 20점

1,2번 swea 문제 풀이와 비슷

3번 단답 및 서술형 : 이진탐색

* 이진탐색이 가능한 최소조건 : 정렬이 되어 있어야 한다.



★ 비트연산자

입력값을 2진수화 한다.

2진수를 bit 단위로 비교한다.

```
print(10 | 5) # 0
# 10 = 1 0 1 0
# 5 =    1 0 1
-----------------------
       0 0 0 0 
```



# 문제풀이

Day3 sum

행의 합

열의 합

대각의 합













